:navorder: 4

# Webhooks in Adobe Sign v6

## On this page
- [Overview](#overview)
- [How do webhooks work?](#howdowebhookswork)
- [Creating a Webhook](#creatingawebhook)
  - [Prerequisites](#prerequisites)
  - [Configure a webhook and subscribe for events](#configureawebhookandsubscribeforevents)
  - [Verification of intent of the webhook URL](#verificationofintentofthewebhookurl)
- [Webhook properties](#webhookproperties)
  - [Webhook URL](#webhookurl)
  - [Webhook status](#webhookstatus)
    - [Active/inactive webhooks](#activeinactivewebhooks)
  - [Webhook scopes](#webhookscopes)
  - [Webhook events](#webhookevents)
  - [Webhook conditional parameters](#webhooksconditionalparameters)
- [Webhook notifications](#webhooknotifications)
  - [Notification payload for events](#notificationpayloadforevents)
  - [SuperSet events](#supersetevents)
  - [Receive a webhook notification](#receiveawebhooknotification)
  - [Reliable delivery of webhook notifications](#reliabledeliveryofwebhooknotifications)
  - [Payload info](#payloadinfo)
- [Managing webhooks and subscriptions (Webhook APIs)](#managingwebhooksandsubscriptionswebhookapis)
  - [Endpoints](#endpoints)
    - [POST /webhooks](#postwebhooks)
    - [GET /webhooks](#getwebhooks)
    - [GET /webhooks/{webhookId}](#getwebhookswebhookid)
    - [PUT /webhooks/{webhookId}](#putwebhookswebhookid)
    - [PUT /webhooks/{webhookId}/state](#putwebhookswebhookidstate)
    - [DELETE /webhooks/{webhookId} ](#deletewebhookswebhookid)
    - [Standard error codes in every API request](#standarderrorcodesineveryapirequest)
    - [Standard headers in every API request](#standardheadersineveryapirequest)
- [Securing webhooks](#securingwebhooks)
- [Best practices](#bestpractices)

## Overview

Webhooks are HTTPS callbacks that receive real-time notification messages for events. When the event occurs, the service makes an HTTPS POST request to the webhook&rsquo;s HTTPS URL. In simple words, a webhook is a **web service that accepts HTTPS POST requests** (rather, listens to requests) from a source. As a developer, you can create webhooks in Adobe Sign to listen to events happening for your agreements and other resources. The webhooks can be created using REST APIs as well as the Adobe Sign web application.

## How do webhooks work?

Webhooks are a useful tool for apps that want to receive and process real-time data updates happening in Adobe Sign; for example, after an agreement is signed, update the status of that agreement in an on-premises Content Management System like SharePoint.

Instead of requiring your application to make an API call every X number of minutes to check for a specific event in Sign (also know as polling), you can now register webhooks in Adobe Sign which will push HTTPS POST notifications to your webhook URL from Sign telling your application that the event has occurred. This Push based model requires fewer API requests overall and provides you with real-time updates, allowing you to build more robust apps and update your application instantly.

Adobe Sign webhooks notifications are generated by changes to the agreement as it progresses from creation to sending to completed or aborted state. In the webhook notification, we provide updated information about the status of these agreements, optionally including the detailed agreement information, information about the documents, participants information and the signed document.

**A simple workflow for webhooks:**

1. Webhook client application (your app) calls POST /webhooks with a user token to create webhook for a resource.
2. Adobe Sign validates that the request and the webhook URL is valid. There is a defined mechanism for this validation where Adobe Sign makes an HTTPS GET request (with the calling application's client id in a custom HTTPS request header) to the webhook URL and the webhook URL is expected to respond in a specific way. You can read in detail about it [**here**](#verificationofintentofthewebhookurl).
3. Adobe Sign sends a success response (any HTTPS 2XX code) to the client app with the unique webhook identifier and Location header which has the URL of the webhook resource created in Sign.
4. Whenever an event happens in Sign, notification for that event will send to the webhook URL.

## Creating a webhook

### Prerequisites

To create webhooks in Sign:

1. Obtain a unique set of application credentials (an application ID and an application secret). Account administrators can generate these credentials through the Adobe Sign API page under "My Profile".
2. Webhook API calls require an [OAuth Access Token](https://secure.echosign.com/public/static/oauthDoc.jsp). Each operation on a resource requires specific OAuth scope(s), and your application will need to request all of the needed scopes during the OAuth authorization process.
3. Use this access tokens received from the OAuth authentication & authorization process in the following REST endpoints to perform operations on behalf of the user who authorized the API access.

#### OAuth scopes for webhooks

In order to call webhook APIs, webhook scopes should be enabled for your application. The scopes - `webhook_read`, `webhook_write` and `webhook_retention`  are needed to call GET, POST/PUT and DELETE APIs respectively.

### Configure a webhook and subscribe to events

To create a webhook in Adobe Sign, configure a webhook URL and register it as a webhook with Adobe Sign specifying the events on which the notifications should be sent. This can be done by calling the `POST /webhooks` API from the **client application** along with the subscription data. The subscription specifies how a subscriber intends to consume events. The first requirement is the foundation by which the subscriptions are managed. At the most basic level, a subscription really needs the following fields:

- **An event name:** The name of the event or events to which you want to subscribe.
- **A resource type and corresponding resource identifier**
- **A webhook URL, to send the event notification to:** A webhook URL is an HTTPS based service that listens at a specific URL for incoming HTTPS POST notification messages that are triggered when events occur.

When a webhook creation call is received, the Sign service first [verifies the intent](#verificationofintentofthewebhookURL) of the webhook URL by making a GET call (see the next section) to the webhook URL. If it succeeds, returns the response of the POST call with  the URL of the newly created webhook resource in the HTTPS Location Header. The HTTPS Location header is returned in response to provide the URL of the newly created webhook resource in Sign. The client service can later make PUT/GET/DELETE calls on this URL.

APIs for webhook subscription management are listed under &ldquo;Managing Webhooks and Subscriptions&rdquo; below.

### Verification of intent of the webhook URL

Before registering a webhook successfully, Adobe Sign verifies that the webhook URL that is provided in the registration request, really intends to receive notifications or not. For this purpose, when a new webhook registration request is received by Adobe Sign, it first makes a verification request to the webhook URL. This verification request is an HTTPS GET request sent to the webhook URL with   a custom HTTP header `X-AdobeSign-ClientId`. The value in this header is set to the client ID of the application that is requesting to create/register the webhook. To successfully register a webhook, the webhook URL must respond to this verification request with a **2XX response code** AND additionaly it must send back the same client id value in one of the following two ways.
- Either in a response header `X-AdobeSign-ClientId` . This is the same header which was passed in the request, and be echoed back in the response.
- Or in the JSON response body with the key of `xAdobeSignClientId` and its value being the same client ID that was sent in the request.

**The webhook will be successfully registered only on a success response(2XX response code) and validation of client id either in header or response body.** The purpose of this verification request is to demonstrate that your webhook URL really does want to receive notifications at that URL. If you accidentally entered the wrong URL, the URL would fail to respond correctly to the verification of intent request, and Adobe Sign will not send any notifications to that URL. Additionally, the webhook URL can also validate that it would receive notifications only through the webhooks which are registered by a specific application. This can be done by validating the client ID of the application passed in the `X-AdobeSign-ClientId` header. If the webhook URL does not recognize that client id, it MUST NOT respond with the success response code and Adobe Sign will take care that the URL is not registered as a webhook.

The verification of webhook URL call will be made in the following scenarios:

- Registering Webhook: If this verification of webhook URL call fails, the webhook will not be created.
- Updating Webhook: INACTIVE to ACTIVE: If this verification of webhook URL call fails, the webhook state will not be changed to ACTIVE.

Additionally, we perform an implicit verification of intent in each webhook notification request that we send to the webhook URL. Thus, every notification request will also include a header called `X-AdobeSign-ClientId`  that includes client id of the application that created the webhook. We will consider the webhook notification successfully delivered, if an only if success response **(2XX response code)** is returned  and  the header **(X-AdobeSign-ClientId)** is echoed back in response HTTP header or in a JSON response body with key as `xAdobeSignClientId` and value as the same client id, otherwise we will retry to deliver the notification to the webhook URL until the retries are exhausted.

## Webhook Properties

### Webhook URL

A webhook URL is a HTTPS based service that listens at a specific URL for incoming HTTPS POST notification messages that are triggered when events occur. After you configure a webhook URL, note the URL for registering with Adobe Sign. You need this URL to subscribe your webhook to the events that you want to be notified of.

- The client must include an HTTPS URL that Adobe Sign can POST to. This URL must be available on the public internet.  For example, 127.0.0.1 and localhost URIs will not work, since Adobe Sign server will not be able to contact your local computer.
- Make sure your webhook supports POST requests for incoming notifications and GET requests for the verification of intent request.
- It should not be blocked by a firewall.

### Webhook Status

- A webhook can be either active or inactive. By default, a webhook is active.
- Adobe Sign will send requests to an active webhook for events as they occur within Adobe Sign.
- Adobe Sign will stop sending requests to a webhook marked as inactive. If an event&rsquo;s request is processing while the webhook is made inactive, this request will finish. Any other existing, unprocessed event requests will be canceled and not sent to your webhook endpoint.
- If an inactive webhook is made active, Adobe Sign will begin sending event requests once more, as soon as new event requests are created.

### Webhooks Scopes

Currently webhooks are supported at Account, Group User account and Resource levels.

- **Account level webhook:** The webhook will be created on a account for all the subscribed events happening in that account.
To create an account level webhook, specify the scope as `ACCOUNT` in the `POST /webhooks` API call. More details for the API are given [below](#post-webhooks).
- **Group level webhook:** The webhook will be created on a group for all the subscribed events happening in that group.
To create a group level webhook, specify the scope as `GROUP` in the `POST /webhooks` API call.
- **User Account level webhook:** The webhook will be created for a user for the events happening for that specific user.
To create user level webhook, specify scope as `USER` in the `POST /webhooks` API call.
- **Resource level webhook:** This will be created for a specific resource. Events specific to this resource will be pushed to the webhook URL. To create a resource level webhook, specify the scope as `RESOURCE`, the resourceType  as `AGREEMENT`  or 
`WIDGET` or `MEGASIGN` and the `resourceId` on which you want to create the webhook in the `POST /webhooks` API call.

### Webhook events
The following is a list of all webhook events:

<table>
   <tr>
      <td>
         <code>AGREEMENT_ACTION_COMPLETED</code>
      </td>
      <td>
         <code>AGREEMENT_KBA_AUTHENTICATED</code>
      </td>
      <td>
         <code>MEGASIGN_ALL</code>
      </td>
   </tr>
   <tr>
      <td>
         <code>AGREEMENT_ACTION_DELEGATED</code>
      </td>
      <td>
         <code>AGREEMENT_MODIFIED</code>
      </td>
      <td>
         <code>MEGASIGN_CREATED</code>
      </td>
   </tr>
   <tr>
      <td>
         <code>AGREEMENT_ACTION_REPLACED_SIGNER</code>
      </td>
      <td>
         <code>AGREEMENT_OFFLINE_SYNC</code>
      </td>
      <td>
         <code>MEGASIGN_RECALLED</code>
      </td>
   </tr>
   <tr>
      <td>
         <code>AGREEMENT_ACTION_REQUESTED</code>
      </td>
      <td>
         <code>AGREEMENT_RECALLED</code>
      </td>
      <td>
         <code>MEGASIGN_SHARED</code>
      </td>
   </tr>
   <tr>
      <td>
         <code>AGREEMENT_ALL</code>
      </td>
      <td>
         <code>AGREEMENT_REJECTED</code>
      </td>
      <td>
         <code>WIDGET_ALL</code>
      </td>
   </tr>
   <tr>
      <td>
         <code>AGREEMENT_AUTO_CANCELLED_CONVERSION_PROBLEM</code>
      </td>
      <td>
         <code>AGREEMENT_SHARED</code>
      </td>
      <td>
         <code>WIDGET_AUTO_CANCELLED_CONVERSION_PROBLEM</code>
      </td>
   </tr>
   <tr>
      <td>
         <code>AGREEMENT_CREATED</code>
      </td>
      <td>
         <code>AGREEMENT_UPLOADED_BY_SENDER</code>
      </td>
      <td>
         <code>WIDGET_CREATED</code>
      </td>
   </tr>
   <tr>
      <td>
         <code>AGREEMENT_DOCUMENTS_DELETED</code>
      </td>
      <td>
         <code>AGREEMENT_USER_ACK_AGREEMENT_MODIFIED</code>
      </td>
      <td>
         <code>WIDGET_DISABLED</code>
      </td>
   </tr>
   <tr>
      <td>
         <code>AGREEMENT_EMAIL_BOUNCED</code>
      </td>
      <td>
         <code>AGREEMENT_VAULTED</code>
      </td>
      <td>
         <code>WIDGET_ENABLED</code>
      </td>
   </tr>
   <tr>
      <td>
         <code>AGREEMENT_EMAIL_VIEWED</code>
      </td>
      <td>
         <code>AGREEMENT_WEB_IDENTITY_AUTHENTICATED</code>
      </td>
      <td>
         <code>WIDGET_MODIFIED</code>
      </td>
   </tr>
   <tr>
      <td>
         <code>AGREEMENT_EXPIRED</code>
      </td>
      <td>
         <code>AGREEMENT_WORKFLOW_COMPLETED</code>
      </td>
      <td>
         <code>WIDGET_SHARED</code>
      </td>
   </tr>
</table>

### Webhooks conditional parameters

When you register a webhook, you can specify whether you want to receive the minimum payload or detailed info using these parameters. The detailed info of resource, participant info, documents info and signed documents can be customized during the creation or update of a webhook. By default, Adobe Sign will send the minimum payload excluding, these attributes in payload info.

## Webhook notifications

### Notification payload for events

When configuring a webhook, you can choose which events for which you would like to receive payloads. Subscribing only to the specific events is useful for limiting the number of HTTPS requests to the server. You can change the list of subscribed events through the API or UI anytime.

Currently webhooks can be created only for agreement, widget, and megasign events. Each event has a similar JSON schema based on the resource type, but a unique payload object that is determined by its event type. The payload will be returned in JSON format.

This table displays the events and payload which will be sent in webhook notification.

| Event type | Description  and payload template |
| --- | --- |
| AGREEMENT_ACTION_COMPLETED | When an agreement is signed by the participant. 


View Payload](webhooks/agreement_action_completed.md) |
| AGREEMENT_ACTION_DELEGATED | When an agreement is delegated by the participant. [View Payload](webhooks/agreement_action_delegated.md) |
| AGREEMENT_ACTION_REPLACED_SIGNER | When an agreement&rsquo;s signer is replaced. [View Payload](webhooks/agreement_action_replaced_signer.md) |
| AGREEMENT_ACTION_REQUESTED | When an agreement action is requested. [View Payload](webhooks/agreement_action_requested.md) |
| AGREEMENT_AUTO_CANCELLED_CONVERSION_PROBLEM | When an agreement is auto-cancelled due to a conversion problem. [View Payload](webhooks/agreement_auto_cancelled_conversion_problem.md) |
| AGREEMENT_CREATED | When an agreement is created. [View Payload](webhooks/agreement_created.md) |
| AGREEMENT_DOCUMENTS_DELETED | When agreement documents are deleted. [View Payload](webhooks/agreement_documents_deleted.md) |
| AGREEMENT_EMAIL_BOUNCED | When an agreement email gets bounced. [View Payload](webhooks/agreement_email_bounced.md) |
| AGREEMENT_EMAIL_VIEWED | When agreement signing email is viewed by the signer. [View Payload](webhooks/agreement_email_viewed.md) |
| AGREEMENT_EXPIRED | When an agreement expires. [View Payload](webhooks/agreement_expired.md) |
| AGREEMENT_KBA_AUTHENTICATED | When an agreement KBA is authenticated. [View Payload](webhooks/agreement_kba_authenticated.md) |
| AGREEMENT_MODIFIED | When an agreement is modified. [View Payload](webhooks/agreement_modified.md) |
| AGREEMENT_OFFLINE_SYNC | When an agreement is synced offline. [View Payload](webhooks/agreement_offline_sync.md) |
| AGREEMENT_RECALLED | When an agreement is cancelled. [View Payload](webhooks/agreement_recalled.md) |
| AGREEMENT_REJECTED | When an agreement is rejected by the participant. [View Payload](webhooks/agreement_rejected.md) |
| AGREEMENT_SHARED | When an agreement is shared. [View Payload](webhooks/agreement_shared.md) |
| AGREEMENT_UPLOADED_BY_SENDER | When an agreement is uploaded by the sender. [View Payload](webhooks/agreement_uploaded_by_sender.md) |
| AGREEMENT_USER_ACK_AGREEMENT_MODIFIED | User acknowledgement when an agreement is modified. [View Payload]
(webhooks/agreement_user_ack_agreement_modified.md) |
| AGREEMENT_VAULTED | When an agreement is vaulted. [View Payload](webhooks/agreement_vaulted.md) |
| AGREEMENT_WEB_IDENTITY_AUTHENTICATED | When an agreement web identity is authenticated. [View Payload](webhooks/agreement_web_identity_authenticated.md) |
| AGREEMENT_WORKFLOW_COMPLETED | When an agreement workflow is completed. [View Payload](webhooks/agreement_workflow_completed.md) |
| MEGASIGN_CREATED | When a megaSign is created. [View Payload](webhooks/megasign_created.md) |
| MEGASIGN_RECALLED | When a megaSign is recalled. [View Payload](webhooks/megasign_recalled.md) |
| MEGASIGN_SHARED | When a megaSign is shared. [View Payload](webhooks/megasign_shared.md) |
| WIDGET_ENABLED | When a widget is enabled. [View Payload](webhooks/widget_enabled.md) |
| WIDGET_DISABLED | When a widget is disabled. [View Payload](webhooks/widget_disabled.md) |
| WIDGET_CREATED | When a widget is created. [View Payload](webhooks/widget_created.md) |
| WIDGET_MODIFIED | When a widget is modified. [View Payload](webhooks/widget_modified.md) |
| WIDGET_SHARED | When a widget is shared. [View Payload](webhooks/widget_shared.md) |
| WIDGET_AUTO_CANCELLED_CONVERSION_PROBLEM | When a widget is auto-cancelled due to a conversion problem. [View Payload](webhooks/widget_auto_cancelled_conversion_problem.md) |

### SuperSet events

If you want to subscribe for all the agreement, widget or megaSign events, you can subscribe to the following events:

| Event type | Description |
| --- | --- |
| `AGREEMENT_ALL` | For all the supported agreement events. If new agreement events are added in future, those events will be taken care of automatically. |
| `WIDGET_ALL`  | For all the supported widget events. If new widget events are added in future, those events will be taken care of automatically. |
| `MEGASIGN_ALL` | All the supported megaSign events for webhooks. |

### Receiving a webhook notification

Once your webhook URL is added, your app will start receiving "notification requests" every time a subscribed event is triggered in Sign. A notification request is an HTTPS POST request with a JSON body. The request's POST parameters will contain JSON data relevant to the event that triggered the request.

Additionally, we perform an implicit verification of intent in each webhook notification request that we send to the webhook URL. Thus, every notification request will also include a header called `X-AdobeSign-ClientId` that includes client id of the application that created the webhook. We will consider the webhook notification successfully delivered, if an only if success response **(2XX response code)** is returned  and  the header **(X-AdobeSign-ClientId)** is echoed back in response HTTP header or in a JSON response body with key as **xAdobeSignClientId** and value as the same client id, otherwise we will retry to deliver the notification to the webhook URL until the retries are exhausted.

### Reliable delivery of webhook notifications

Adobe Sign follows a more advanced, more reliable strategy for delivery of these webhook notifications. If there is an outage on the receiving end (for example, the customer's server is down), we make attempts to retry the notification at a later time&mdash;minutes or hours later.

The undelivered events will be persisted in a retry queue and a best effort will be made over the course of a configurable amount of time (such as 72 hours) to deliver the notifications in the order they occurred to the client-provided endpoints. The strategy for retrying delivery of notifications is a doubling of time between attempts, starting with a one-minute interval increasing to every 12 hours, resulting in 15 retries in the space of 72 hours. If the webhook server fails to respond and either the maximum retry time or maximum retry hours are exceeded, the webhook will be disabled. No notifications will be sent to this URL until the webhook is activated again. In addition, all the notifications between the time the webhook is disabled and enabled again will be lost.

### Payload info

Webhook notification payloads will be delivered using the `application/json` content type.

This payload object contains all the relevant information about what just happened, including the type of event and the data associated with that event. Adobe Sign then sends the payload object, via an HTTPS POST request, to any endpoint URLs that you have defined as a webhook URL. Payload size is restricted using the setting `MAX_WEBHOOK_NOTIFICATION_PAYLOAD_SIZE`.

If an event generates a larger payload, a webhook will triggered, but the conditional parameters&rsquo; attributes, if they&rsquo;re in the request, will be removed to reduce the size of the payload. Also, Adobe Sign will return a `conditionalParametersTrimmed` attribute in the response for this case to tell the client that _conditionalParameters_ info is removed.

The `conditionalParametersTrimmed` object is an **array** object containing the information about the keys that have been trimmed. This may happen, for example, for an agreement completion event if it includes a signed document (base 64 encoded) as well, or for an agreement with multiple form fields.

The truncation will be done in the following order:

- **includeSignedDocuments**
- **includeParticipantsInfo**
- **includeDocumentsInfo**
- **includeDetailedInfo**

## Managing webhooks and subscriptions (webhook APIs)

Adobe Sign APIs lets you do the following with the Webhook resource:

- [POST /webhooks ](#postwebhooks) Creates a new webhook.
- [GET /webhooks](#getwebhooks) Retrieves webhooks for a user.
- [GET /webhooks/{webhookId}](#getwebhookswebhookid) Retrieves details of a webhook.
- [PUT /webhooks/{webhookId}](#putwebhookswebhookid) Modifies an existing webhook.
- [PUT /webhooks/{webhookId}/state](#putwebhookswebhookidstate) Modifies an existing webhook&rsquo;s status(ACTIVE/INACTIVE).
- [DELETE /webhooks/{webhookId}](#deletewebhookswebhookid) Deletes a webhook.

### Endpoints

#### POST /webhooks

<table>
  <thead>
    <tr>
      <th>Entity</th>
      <th>Value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Description</td>
      <td>Creates a webhook</td>
    </tr>
    <tr>
      <td>Endpoint operation</td>
      <td><code>/webhooks</code></td>
    </tr>
    <tr>
      <td>OAuth scopes</td>
      <td><code>webhook_write</code></td>
    </tr>
    <tr>
      <td>Request object</td>
      <td>:<code>WebhookInfo:</code>
        <pre>
{
   "name": "",
   "scope": "",
   "state": "",
   "webhookSubscriptionEvents": [
      ""
   ],
   "webhookUrlInfo": {
      "url": ""
   },
   "applicationDisplayName": "",
   "applicationName": "",
   "created": "",
   "id": "",
   "lastModified": "",
   "resourceId": "",
   "resourceType": "",
   "status": "",
   "webhookConditionalParams": {
      "webhookAgreementEvents": {
         "includeDetailedInfo": false,
         "includeDocumentsInfo": false,
         "includeParticipantsInfo": false,
         "includeSignedDocuments": false
      },
      "webhookMegaSignEvents": {
         "includeDetailedInfo": false
      },
      "webhookWidgetEvents": {
         "includeDetailedInfo": false,
         "includeDocumentsInfo": false,
         "includeParticipantsInfo": false
      }
   }
}
</pre></td>
    </tr>
    <tr>
      <td>Response header</td>
      <td>Location Header specifying the resource location of the webhook</td>
    </tr>
    <tr>
      <td>Response content type</td>
      <td><code>application/json</code></td>
    </tr>
    <tr>
      <td>Response object </td>
      <td><code>WebhookCreationResponse</code>
        <pre>{
   "id" : ""
}</pre></td>
    </tr>
    <tr>
      <td>HTTPS status code</td>
      <td>201</td>
    </tr>
    <tr>
      <td>Error code</td>
      <td>Please note that new errors could be returned from APIs or existing error codes can be evolved. Clients are expected to be prepared to do default handling for error scenarios which they do not understand.
        <table>
          <thead>
            <tr>
              <th>HTTPS status code</th>
              <th>Error code</th>
              <th>Message</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>400</td>
              <td><code>INVALID_ARGUMENTS</code></td>
              <td>One or more arguments to the method are invalid.</td>
            </tr>
            <tr>
              <td>400</td>
              <td><code>INVALID_WEBHOOK_URL</code></td>
              <td>The Webhook URL specified is invalid.</td>
            </tr>
            <tr>
              <td>400</td>
              <td><code>INVALID_RESOURCE_ID</code></td>
              <td>Resouce Id specified is invalid.</td>
            </tr>
            <tr>
              <td>400</td>
              <td><code>INVALID_RESOURCE_TYPE</code></td>
              <td>The resource type is invalid.</td>
            </tr>
            <tr>
              <td>400</td>
              <td><code>INVALID_WEBHOOK_CONDITIONAL_PARAMS</code></td>
              <td>The conditional parameters specified are invalid.</td>
            </tr>
            <tr>
              <td>400</td>
              <td><code>MISSING_REQUIRED_PARAM</code></td>
              <td>The required parameters are missing. </td>
            </tr>
            <tr>
              <td>400</td>
              <td><code>WEBHOOK_LIMIT_EXCEEDED</code></td>
              <td>This webhook can&rsquo;t be created. The events array <code>{events}</code> has reached the maximum number of active webhooks.</td>
            </tr>
            <tr>
              <td>400</td>
              <td><code>DUPLICATE_WEBHOOK_CONFIGURATION</code></td>
              <td>There is already a webhook registered with same configuration.</td>
            </tr>
            <tr>
              <td>400</td>
              <td><code>INVALID_WEBHOOK_STATE</code></td>
              <td>The webhook state specified is invalid.</td>
            </tr>
            <tr>
              <td>400</td>
              <td><code>INVALID_WEBHOOK_SUBSCRIPTION_EVENTS</code></td>
              <td>One or more webhook subscription events specified are invalid.</td>
            </tr>
            <tr>
              <td>403</td>
              <td><code>WEBHOOK_CREATION_NOT_ALLOWED</code></td>
              <td>Webhook creation is not allowed.</td>
            </tr>
          </tbody>
        </table></td>
    </tr>
  </tbody>
</table>

This API will be used to create a webhook on a particular resouce in Adobe Sign.

- You need to register the webhook with your application and a user token using this API.
- Group-level webhooks can only be created by a Group admin and account-level webhooks can only be created by an Account admin.
- The user can customize the events for which the webhook is triggered in this call.

The `HTTPS Location` header field is returned in the response to provide information about the location of a newly created resource. Multiple webhooks can be created on a single resource. _Also, multiple webhooks can share the same URL._

#### GET /webhooks

<table>
  <thead>
    <tr>
      <th>Entity</th>
      <th>Value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Description</td>
      <td>Get a list of webhooks created by the access token user.</td>
    </tr>
    <tr>
      <td>OAuth scopes</td>
      <td><code>webhook_read</code></td>
    </tr>
    <tr>
      <td>Query parameters</td>
      <td><p><code>showInactiveWebhooks: boolean</code>: A query parameter to fetch all the inactive webhooks along with the active webhooks.</p>
      <p><code>scope</code>: Scope of the webhook. The possible values are <code>ACCOUNT</code>, <code>GROUP</code>, <code>USER</code>, or <code>RESOURCE</code>.</p>
      <p><code>resourceType</code>: The type of resource on which webhook was created. The possible values are <code>AGREEMENT</code>, <code>WIDGET</code>, and <code>MEGASIGN</code>.</p>
</td>
    </tr>
    <tr>
      <td>Response content type</td>
      <td><code>application/json</code></td>
    </tr>
    <tr>
      <td>Response object </td>
      <td><code>WebhooksInfo</code>
         <pre>{
   "userWebhookList": [
      {
         "applicationName": "Application for REST Swagger Documentation",
         "applicationId": "pUQL757H2R2",
         "id": "CBJCHBCAABAAtW5qb_gRDgssqn6tvLvCcav0VqYi0WTR",
         "name": "user level webhook",
         "lastModified": "2018-02-06T22:52:27-08:00",
         "scope": "USER",
         "webhookSubscriptionEvents": [
            "AGREEMENT_RECALLED"
         ],
         "webhookUrlInfo": {
            "url": "https://testUrl"
         },
         "status": "ACTIVE"
      },
      {
         "applicationName": "Application for REST Swagger Documentation",
         "applicationDisplayName ": "REST Swagger",
         "id": "CBJCHBCAABAAtW5qb_gRDgssqn6tvLvCcav0VqYi0WTR",
         "name": "",
         "lastModified": "2018-02-06T22:52:27-08:00",
         "scope": "RESOURCE",
         "resourceType": "AGREEMENT",
         "resourceId": "3dffwifvgvfguierfreokfperfprfppr",
         "webhookSubscriptionEvents": [
            "AGREEMENT_RECALLED"
         ],
         "webhookUrlInfo": {
            "url": "https://testResource"
         },
         "status": "ACTIVE"
      }
   ],
   "page": {
      "nextCursor": " "
   }
}
        </pre></td>
    </tr>
    <tr>
      <td>HTTPS status code</td>
      <td>200</td>
    </tr>
    <tr>
      <td>Error code</td>
      <td>Please note that new errors could be returned from APIs or existing error codes can be evolved. Clients are expected to be prepared to do default handling for error scenarios which they do not understand. 
        <table>
          <thead>
            <tr>
              <th>HTTPS status code</th>
              <th>Error code</th>
              <th>Message</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>400</td>
              <td><code>INVALID_ARGUMENTS</code></td>
              <td>One or more arguments to the method are invalid.</td>
            </tr>
            <tr>
              <td>400</td>
              <td><code>INVALID_CURSOR<code></td>
              <td>The page cursor provided is invalid.</td>
            </tr>
            <tr>
              <td>400</td>
              <td><code>INVALID_PAGE_SIZE<code></td>
              <td>Page size is either invalid or not within the permissible range.</td>
            </tr>
          </tbody>
        </table></td>
    </tr>
  </tbody>
</table>

#### GET /webhooks/{webhookId}

<table>
  <thead>
    <tr>
      <th>Entity</th>
      <th>Value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Description</td>
      <td>List details of a webhook.</td>
    </tr>
    <tr>
      <td>Endpoint operation</td>
      <td><code>/webhhooks/{webhookId}</code></td>
    </tr>
    <tr>
      <td>OAuth scopes</td>
      <td><code>webhook_read</code></td>
    </tr>
    <tr>
      <td>Response content type</td>
      <td><code>application/json</code></td>
    </tr>
    <tr>
      <td>Response object</td>
      <td><code>WebhookInfo</code>
        <pre>{
    "scope": "",
    "webhookSubscriptionEvents": [
        ""
    ],
    "webhookUrlInfo": {
        "url": ""
    },
    "name": "",
    "status": "",
    "applicationDisplayName ": "",
    "applicationName": "",
    "created": "date",
    "id": "",
    "lastModified": "date",
    "resourceId": "",
    "resourceType": "",
    "webhookConditionalParams": {
        "webhookAgreementEvents": {
            "includeDetailedInfo": false,
            "includeDocumentsInfo": false,
            "includeParticipantsInfo": false,
            "includeSignedDocuments": false
        },
        "webhookMegaSignEvents": {
            "includeDetailedInfo": false
        },
        "webhookWidgetEvents": {
            "includeDetailedInfo": false,
            "includeDocumentsInfo": false,
            "includeParticipantsInfo": false
        }
    }
}</pre></td>
    </tr>
    <tr>
      <td>HTTPS status code</td>
      <td>200</td>
    </tr>
    <tr>
      <td>Error code</td>
      <td>Please note that new errors could be returned from APIs or existing error codes can be evolved. Clients are expected to be prepared to do default handling for error scenarios which they do not understand. 
        <table>
          <thead>
            <tr>
              <th><strong>HTTPS status code</strong></th>
              <th><strong>Error code</strong></th>
              <th><strong>Message</strong></th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>304</td>
              <td><code>RESOURCE_NOT_MODIFIED</code></td>
              <td>The resource is not modified.</td>
            </tr>
            <tr>
              <td>404</td>
              <td><code>INVALID_WEBHOOK_ID</code></td>
              <td>The <code>webhookId</code> specified is invalid.</td>
            </tr>
          </tbody>
        </table></td>
    </tr>
  </tbody>
</table>

#### PUT /webhooks/{webhookId}

<table>
  <thead>
    <tr>
      <th>Entity</th>
      <th>Value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Description</td>
      <td>This endpoint is used to update the webhook resource.</td>
    </tr>
    <tr>
      <td>Endpoint operation</td>
      <td><code>/webhooks/{webhookId}</code></td>
    </tr>
    <tr>
      <td>OAuth scopes</td>
      <td><code>webhook_write</code></td>
    </tr>
    <tr>
      <td>Request header</td>
      <td>Standard header. Additionally, If-Match headers, which will be processed as per the Concurrency section of the DC API Guidelines</td>
    </tr>
    <tr>
      <td>Request body</td>
      <td><code>WebhookInfo</code>
        <pre>{
   "name": "",
   "scope": "",
   "state": "",
   "webhookSubscriptionEvents": [
      ""
   ],
   "webhookUrlInfo": {
      "url": ""
   },
   "applicationDisplayName": "",
   "applicationName": "",
   "created": "",
   "id": "",
   "lastModified": "",
   "resourceId": "",
   "resourceType": "",
   "status": "",
   "webhookConditionalParams": {
      "webhookAgreementEvents": {
         "includeDetailedInfo": false,
         "includeDocumentsInfo": false,
         "includeParticipantsInfo": false,
         "includeSignedDocuments": false
      },
      "webhookMegaSignEvents": {
         "includeDetailedInfo": false
      },
      "webhookWidgetEvents": {
         "includeDetailedInfo": false,
         "includeDocumentsInfo": false,
         "includeParticipantsInfo": false
      }
   }
}</pre></td>
    </tr>
    <tr>
      <td>Response content type</td>
      <td><code>application/json</code></td>
    </tr>
    <tr>
      <td>Response object </td>
      <td>Empty response</td>
    </tr>
    <tr>
      <td>HTTPS status code</td>
      <td>204</td>
    </tr>
    <tr>
      <td>Error code</td>
      <td>Please note that new errors could be returned from APIs or existing error codes can be evolved. Clients are expected to be prepared to do default handling for error scenarios which they do not understand.
        </p>
        <table>
          <thead>
            <tr>
              <th>HTTPS status code </th>
              <th>Error code</th>
              <th>Message</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>400</td>
              <td><code>MISSING_REQUIRED_PARAM</code></td>
              <td>Required parameters are missing.</td>
            </tr>
            <tr>
              <td>400</td>
              <td><code>DUPLICATE_WEBHOOK_CONFIGURATION</code></td>
              <td>There is already a webhook registered with same configuration.</td>
            </tr>
            <tr>
              <td>400</td>
              <td><code>INVALID_JSON</code></td>
              <td>An invalid JSON was specified.</td>
            </tr>
            <tr>
              <td>400</td>
              <td><code>INVALID_WEBHOOK_CONDITIONAL_PARAMS</code></td>
              <td>The webhook conditional parameters specified are invalid.</td>
            </tr>
            <tr>
              <td>400</td>
              <td><code>INVALID_WEBHOOK_SUBSCRIPTION_EVENTS</code></td>
              <td>One or more webhook subscription events specified are invalid.</td>
            </tr>
            <tr>
              <td>400</td>
              <td><code>MISSING_IF_MATCH_HEADER</code></td>
              <td>The If-Match header missing.</td>
            </tr>
            <tr>
              <td>400</td>
              <td><code>UPDATE_NOT_ALLOWED</code></td>
              <td>The webhook you are trying to update cannot be modified.</td>
            </tr>
            <tr>
              <td>400</td>
              <td><code>WEBHOOK_LIMIT_EXCEEDED</code></td>
              <td>This webhook can&rsquo;t be activated. The resource has reached the maximum number of active webhooks.</td>
            </tr>
            <tr>
              <td>404</td>
              <td><code>INVALID_WEBHOOK_ID</code></td>
              <td>The <code>webhookId</code> is invalid.</td>
            </tr>
            <tr>
              <td>412</td>
              <td><code>RESOURCE_MODIFIED</code></td>
              <td>The resource is already modified with a newer version.</td>
            </tr>
          </tbody>
        </table></td>
    </tr>
  </tbody>
</table>

Only events and conditional parameters can be  modified. The webhook URL can&rsquo;t be modified once the webhook is created. The modification can also be done in the INACTIVE state.

#### PUT /webhooks/{webhookId}/state

<table>
  <thead>
    <tr>
      <th>Entity</th>
      <th>Value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Description</td>
      <td>This endpoint will update the state of a webhook identified by <code>webhookId</code> in the path.</td>
    </tr>
    <tr>
      <td>Endpoint operation</td>
      <td><code>/webhooks/{webhookId}/state</code></td>
    </tr>
    <tr>
      <td>OAuth scopes</td>
      <td><code>webhook_write</code></td>
    </tr>
    <tr>
      <td>Request header</td>
      <td>Standard header. Additionally, If-Match headers, which will be processed as per the Concurrency section of the DC API Guidelines.</td>
    </tr>
    <tr>
      <td>Request body</td>
      <td><code>WebhookInfo</code>
        <pre>{
   "state": ""
}</pre></td>
    </tr>
    <tr>
      <td>Response content type</td>
      <td><code>application/json</code></td>
    </tr>
    <tr>
      <td>Response object</td>
      <td>Empty response</td>
    </tr>
    <tr>
      <td>HTTPS status code</td>
      <td>204</td>
    </tr>
    <tr>
      <td>Error code</td>
      <td>Please note that new errors could be returned from APIs or existing error codes can be evolved. Clients are expected to be prepared to do default handling for error scenarios which they do not understand.
        </p>
        <table>
            <thead>
                <tr>
                    <th>HTTPS status code</th>
                    <th>Error code</th>
                    <th>Message</th>
                </tr>
            </thead>
          <tbody>
            <tr>
              <td>400</td>
              <td><code>MISSING_REQUIRED_PARAM</code></td>
              <td>Required parameters are missing. </td>
            </tr>
            <tr>
              <td>400</td>
              <td><code>DUPLICATE_WEBHOOK_CONFIGURATION</code></td>
              <td>There is already a webhook registered with same configuration.</td>
            </tr>
            <tr>
              <td>400</td>
              <td><code>INVALID_JSON</code></td>
              <td>An invalid JSON was specified.</td>
            </tr>
            <tr>
              <td>400</td>
              <td><code>MISSING_IF_MATCH_HEADER</code></td>
              <td>The If-Match header is missing.</td>
            </tr>
            <tr>
              <td>400</td>
              <td><code>UPDATE_NOT_ALLOWED</code></td>
              <td>The webhook you are trying to update cannot be modified.</td>
            </tr>
            <tr>
              <td>400</td>
              <td><code>WEBHOOK_LIMIT_EXCEEDED</code></td>
              <td>This webhook can&rsquo;t be activated. The resource has reached the maximum number of active webhooks.</td>
            </tr>
            <tr>
              <td>404</td>
              <td><code>INVALID_WEBHOOK_ID</code></td>
              <td>The <code>webhookId</code> is invalid.</td>
            </tr>
            <tr>
              <td>412</td>
              <td><code>RESOURCE_MODIFIED</code></td>
              <td>The resource is already modified with a newer version.</td>
            </tr>
          </tbody>
        </table></td>
    </tr>
  </tbody>
</table>

#### DELETE /webhooks/{webhookId}

<table>
  <thead>
    <tr>
      <th>Entity</th>
      <th>Value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Description</td>
      <td>This endpoint is used to delete the webhook resource. This is the terminal state of the webhook and the action is irreversible.</td>
    </tr>
    <tr>
      <td>Endpoint operation</td>
      <td><code>/webhooks/{webhookId}</code></td>
    </tr>
    <tr>
      <td>OAuth scopes</td>
      <td><code>webhook_delete</code></td>
    </tr>
    <tr>
      <td>Request header</td>
      <td>Standard header</td>
    </tr>
    <tr>
      <td>HTTPS status code</td>
      <td>204</td>
    </tr>
    <tr>
      <td>Error code</td>
      <td>Please note that new errors could be returned from APIs or existing error codes can be evolved. Clients are expected to be prepared to do default handling for error scenarios which they do not understand.
        <table>
          <thead>
            <tr>
              <th>HTTPS status code </th>
              <th>Error code</th>
              <th>Message</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>403 </td>
              <td><code>FORBIDDEN</code></td>
              <td>Delete is not allowed.</td>
            </tr>
            <tr>
              <td>404</td>
              <td><code>INVALID_WEBHOOK_ID</code></td>
              <td>The webhookId is invalid.</td>
            </tr>
          </tbody>
        </table></td>
    </tr>
  </tbody>
</table>

#### Standard error codes in every API request

Any API request may return any of these standard error codes:

| HTTPS status code | Error code | Message |
| --- | --- | --- |
| 400 | `BAD_REQUEST` | The request provided is invalid. |
| 400 | `INVALID_JSON` | An invalid JSON was specified. |
| 400 | `INVALID_ON_BEHALF_OF_USER_HEADER` | The value provided in the `x-on-behalf-of-user` header is in invalid format. |
| 400 | `INVALID_X_API_USER_HEADER` | The value provided in `x-api-user` header is in invalid format. |
| 400 | `MISC_ERROR` | Some miscellaneous error has occurred. |
| 401 | `UNAUTHORIZED` | You cannot work on behalf of this user. |
| 401 | `UNVERIFIED_USER` | The user has registered but has not verified their email address. The user must use the Adobe Sign web site to complete verification. |
| 401 | `NO_AUTHORIZATION_HEADER` | The authorization header was not provided. |
| 401 | `INVALID_ACCESS_TOKEN` | The access token provided is invalid or has expired. |
| 401 | `INVALID_USER` |An invalid user ID or email was provided in the  `x-user` header. |
| 401 | `INVALID_ON_BEHALF_OF_USER` | An invalid user ID or email was provided in the `x-on-behalf-of-user` header. |
| 403 | `API_TERMS_NOT_ACCEPTED` | Your account is locked because an administrator has not agreed to Adobe Sign&rsquo;s Terms of Use. Please contact your account administrator to activate your account. |
| 404 | `PERMISSION_DENIED` | The API caller does not have the permission to execute this operation. |
| 500 | `MISC_SERVER_ERROR` | Some miscellaneous server error has occurred. |

#### Standard headers in every API request

Every API request will have the following standard headers. If Any API in the list above does not have one or more of the following headers, the API will explicitly document this fact.

| Header Name | Description |
| --- | --- |
| `AUTHORIZATION` | An access token with correct scopes. |
| `x-api-user` | The userId or email of the API caller using the account or group token in the format  `userid:{userId}` **OR** `email:{email}.`  If it is not specified, then the caller is inferred from the token. |
| `x-on-behalf-of-user`  | Account sharing: The user on whose behalf the API caller is working. |

## Securing webhooks
Adobe Sign is securing your webhooks in following ways:

- **Allowing only HTTPS URLs:** Only HTTPS URLs are permitted to register as webhook urls.

- **Validating webhooks subscription for authentication and authorization for webhooks created through the API:** This is done using the existing API authentication and authorization validation in Sign. The first step for securing Adobe Sign webhooks is to include the standard authentication mechanism (OAuth access token and authorization header). While setting up a webhook subscription, we will validate that the token is valid and the API caller has permissions to create a webhook on the resource. We will also validate that the API caller has appropriate authorization to create account-level webhooks.

- **Two-way SSL authentication:** Adobe Sign supports a two-way SSL handshake when making callbacks to our customer&rsquo;s servers. Two-way SSL, often called Client-Side SSL, is a mode of SSL wherein both the server and the client (web browser) present certificates to identify themselves. We allow the account admins, via their account Security Settings page, to upload an identifying certificate, which the AdobeSign webhooks system will use to identify itself when making webhook calls to their servers. Adobe Sign will verify SSL certificates when delivering payloads to HTTPS webhook addresses. Webhooks that fail the SSL certificate verification will not successfully deliver to their respective hosts. Please ensure your server is correctly configured to support HTTPS with a valid SSL certificate.

- **Keeping the webhook configuration immutable:** If your webhook URL changes, there is a possibility that your application consumer key and consumer secret have been compromised. By requiring you to create a new webhook configuration, we also require you to resubscribe to your user&rsquo;s events. This requires the use of access tokens that a malicious party is less likely to posses. As a result, the likelihood that another party will receive your user&rsquo;s private information is reduced.

- **Sending and receiving the client ID in the webhook notification request:** You can whitelist the client/application ids through which you want to receive the payload. Notifications from the remaining apps can be ignored.

- **Recommended server configurations:** We are only supporting TLS 1.2 for webhooks. TLS 1.0 and 1.1 are not supported.

- **IP validation:** To prevent setting an internal subnet (for example, a 10.x address), special IP address ranges such as the 169.254.169.254 range, and other invalid IP addresses as webhook URLs, Adobe Sign will validate the IP address at the time of webhook creation as well as while sending notifications. If the IP address is invalid, the webhook will not be created. IP validation is done in the following way:

    1. The host name is resolved using DNS lookup.

    2. The IP address obtained is validated. The following IP addresses are considered invalid and a webook cannot be created using them:  
        - SiteLocalAddress
        - LoopbackAddress
        - LinkLocalAddress
        - AnyLocalAddress
        - MulticastAddress

- **Avoid sending sensitive information:** Adobe Sign will not send any sensitive information such as passwords or signing URLs in the payload.

## Best practices

- **Be prepared to dedupe events:** If you have more than one app sharing the same webhook URL and the same user mapped to each app, the same event will be sent to your webhook multiple times (once per app). In some cases your webhook may receive duplicate events. Your webhook application should be tolerant of this and dedupe by event ID.
- **Always respond to webhook requests quickly:** Your app only has ten seconds to respond to webhook requests. For the verification request, this is never really an issue, since your app doesn&rsquo;t need to do any real work to respond. For notification requests, however, your app will usually do something that takes time in response to the request. For example, it may need to process and then store signed documents. To make sure you can always respond within ten seconds, you should always do your work on a separate thread or asynchronously, using a queue.
- **Manage concurrency:** When a user makes a number of changes in rapid succession, your app is likely to receive multiple notifications for the same user at roughly the same time. If you&rsquo;re not careful about how you manage concurrency, your app can end up processing the same changes for the same user more than once.

    To take advantage of Adobe Sign webhooks, a clear understanding of the use of the information needs to be understood. Be sure to ask questions such as: 1. What data do you want to return in payload? 2. Who will be accessing this information? 3. What decisions or reporting will be generated?

- **Recommendations for receiving signed documents:** There are several factors to consider when determining how to receive agreements  (signed PDFs) from Adobe Sign in your document management system. While it is perfectly acceptable to just select the IncludeSignedDocument option while creating a webhook to include the PDF documents when an event is triggered, you might consider using the Adobe Sign API to retrieve the documents when a triggering event (such as agreement status Complete) is received.

